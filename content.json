{"pages":[{"title":"about","text":"…","link":"/about/index.html"}],"posts":[{"title":"Block、 Proc 與 Lambda","text":"在Ruby中，大部分東西都是物件，Block是少數的例外 Block 是什麼呢？？？對於新手如我就是do…end或是{ …. }這種東西 123456#常見範例ㄧ[1,2,3,4,5].each do |i| p iend#常見範例二[1,2,3,4,5].each{|i| p i } 如果想要讓附掛在 methods 後的 Block 執行，可使用 yield 方法，暫時把控制權交棒給 Block，等 Block 執行結束後再把控制權交回來： 1234567def say_hi yield #這邊換成block開始動 p &quot;hello&quot;endsay_hi{ p &quot;hi&quot;}#&quot;hi&quot;#&quot;hello&quot; 那麼Proc 跟 Lambda呢～就是把block物件化然後能丟來丟去的神秘力量了～ 1234567891011121314Proc.new { p &quot;hi&quot; }proc { p &quot;hi&quot; }lambda { p &quot;hi&quot; }-&gt;i{ p &quot;hi&quot; }#&lt;Proc:0x00007fbebe176ce8@(irb):14&gt;#&lt;Proc:0x00007fbebe1c2968@(irb):15&gt;#&lt;Proc:0x00007fbebe1c9c40@(irb):16 (lambda)&gt;#&lt;Proc:0x00007fbebe1d98c0@(irb):17 (lambda)&gt;#丟到methoddef say_hi(proc) proc.callendproc = Proc.new { p &quot;hi&quot; }say_hi(proc) #&quot;hi&quot; lambda 和 Proc 的差異lambda 和 Proc 幾乎一模一樣，除了： lambda 會檢查代入的參數數目，Proc 不會。因此當丟入的參數數目不對時，lambda 會丟出錯誤，而 proc 只會忽略未預期的參數並代入 nil。 1234567say_hello_lambda = lambda { |first_name, last_name| puts &quot;Hello #{first_name}, #{last_name}.&quot;}say_hello_proc = Proc.new { |first_name, last_name| puts &quot;Hello #{first_name}, #{last_name}.&quot;}say_hello_lambda.call('Aaron') # wrong number of arguments (given 1, expected 2)say_hello_proc.call('Aaron') # Hello Aaron, . 當 lambda 內執行到 return 後，它會將控制權交回呼叫它的方法，繼續執行該方法後的片段；但當 Proc 內使用到 return 時，不會回到呼叫它的方法，而是立即跳出該方法： 123456789101112131415def say_hi_if_in_good_mood_proc greeting = Proc.new { return &quot;hi!&quot; } greeting.call &quot;I had a bad day&quot;endputs say_hi_if_in_good_mood_proc # hi!def say_hi_if_in_good_mood_lambda greeting = lambda { return &quot;hi!&quot; } greeting.call &quot;I had a bad day&quot;endputs say_hi_if_in_good_mood_lambda # I had a bad day","link":"/2020/01/29/Block%E3%80%81-Proc-%E8%88%87-Lambda/"},{"title":"Rails database indexing 的心得與測試","text":"關於Database indexing的介紹與運作方式這邊請 https://medium.com/@jinghua.shih/rails-%E7%B6%B2%E7%AB%99%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96-%E4%BA%8C-%E8%B3%87%E6%96%99%E5%BA%AB%E7%B4%A2%E5%BC%95-database-index-bd89fa3757a 以下紀錄自己嘗試的結果：試著從tasks這張table中撈出:topic =&gt; “test”的這筆資料，第一次測試，資料總共六筆。 12345678Task.where(topic: 'test').explain Task Load (0.5ms) SELECT &quot;tasks&quot;.* FROM &quot;tasks&quot; WHERE &quot;tasks&quot;.&quot;topic&quot; = $1 [[&quot;topic&quot;, &quot;test&quot;]] =&gt; EXPLAIN for: SELECT &quot;tasks&quot;.* FROM &quot;tasks&quot; WHERE &quot;tasks&quot;.&quot;topic&quot; = $1 [[&quot;topic&quot;, &quot;test&quot;]] QUERY PLAN------------------------------------------------------- Seq Scan on tasks (cost=0.00..1.07 rows=1 width=120) Filter: ((topic)::text = 'test'::text)(2 rows) 加上index 123def change add_index :tasks, :topicend 再撈一次試試看 12345678Task.where(topic: 'test').explain Task Load (0.8ms) SELECT &quot;tasks&quot;.* FROM &quot;tasks&quot; WHERE &quot;tasks&quot;.&quot;topic&quot; = $1 [[&quot;topic&quot;, &quot;test&quot;]] =&gt; EXPLAIN for: SELECT &quot;tasks&quot;.* FROM &quot;tasks&quot; WHERE &quot;tasks&quot;.&quot;topic&quot; = $1 [[&quot;topic&quot;, &quot;test&quot;]] QUERY PLAN------------------------------------------------------- Seq Scan on tasks (cost=0.00..1.07 rows=1 width=120) Filter: ((topic)::text = 'test'::text)(2 rows) 對比前後兩次結果，發現所需時間怎麼變久了呢？那我們把資料數兩增加到一百筆呢？ 這是沒有加index的結果 12345678Task.where(topic: '鄔嘉宏').explain Task Load (0.6ms) #SELECT &quot;tasks&quot;.* FROM &quot;tasks&quot; WHERE &quot;tasks&quot;.&quot;topic&quot; = $1..... QUERY PLAN------------------------------------------------------- Seq Scan on tasks (cost=0.00..2.15 rows=1 width=120) Filter: ((topic)::text = '鄔嘉宏'::text)(2 rows) 加了之後 12345678Task.where(topic: '符雅芳').explain Task Load (0.5ms) SELECT &quot;tasks&quot;.* FROM &quot;tasks&quot; WHERE &quot;tasks&quot;.&quot;topic&quot; = $..... QUERY PLAN------------------------------------------------------- Seq Scan on tasks (cost=0.00..3.23 rows=1 width=120) Filter: ((topic)::text = '符雅芳'::text)(2 rows) 在資料數目不多的時候，加上index搜尋時（我猜測）會多查詢該欄的參照表格，反而要多查詢一次，因此速度較慢，但若資料數非常多的話，有加上index效能就會改善不少。關於index有很多種不同的運作方式例如：B-tree index、GiST indexes、GIN但我的能力還不足以了解使用時機跟方法，日後回顧這篇文章時再將其補完。 參考資料：https://karolgalanciak.com/blog/2018/08/19/indexes-on-rails-how-to-make-the-most-of-your-postgres-database/https://xguox.me/rubyist-guide-to-postgres-explain.html/https://bamboolab.eu/blog/rails-postgresql-index-btree-gin-gisthttps://medium.com/@jinghua.shih/rails-%E7%B6%B2%E7%AB%99%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96-%E4%BA%8C-%E8%B3%87%E6%96%99%E5%BA%AB%E7%B4%A2%E5%BC%95-database-index-bd89fa3757a","link":"/2020/02/11/Rails-database-indexing-%E7%9A%84%E5%BF%83%E5%BE%97%E8%88%87%E6%B8%AC%E8%A9%A6/"},{"title":"Rails 中的Scope","text":"在rails 中要查詢資料表時，我們常常用where, find, find_by，或是自己寫class method，如果碰到要求特別的情況也可以用Scope來客製化自己的查詢方法，Scope會回傳ActiveRecord::Relation 或是 nil 所以還可以串接使用，讓程式碼更簡潔。 123class Article &lt; ApplicationRecord scope :published, -&gt; { where(published: true) }end scope還可以把scope包進去 1234class Article &lt; ApplicationRecord scope :published, -&gt; { where(published: true) } scope :published_and_commented, -&gt; { published.where(&quot;comments_count &gt; 0&quot;) }end 如果希望scope的目標是全部 123class Client &lt; ApplicationRecord default_scope { where(&quot;removed_at IS NULL&quot;) }end 那scope跟自己在model中客製化的class method相較起來除了能讓程式碼更簡潔之外還有什麼不同呢？這邊來做個小實驗 123456789101112131415class User &lt; ApplicationRecord scope :by_name_v1, -&gt; name { where(name: name) if name.present? } scope :recent_v1, -&gt; { order(&quot;users.updated_at DESC&quot;) } def self.recent_v2 order(&quot;users.updated_at DESC&quot;) end def self.by_name_v2(name) where(name: name) if name.present? endendUser.by_name_v1(nil).recent_v1#User Load (0.7ms) SELECT &quot;users&quot;.* FROM &quot;users&quot; ORDER BY users.updated_at DESC LIMIT $1 看起來沒事User.by_name_v2(nil).recent_v2#NoMethodError (undefined method `recent_v2' for nil:NilClass)Bang!爆炸了 為什麼呢？ 其實這段改成這樣寫兩個結果就一樣了 1234567def self.by_name_v2(name) if name.present? where(name: name) else all endend 我的心得是，如果在自訂類別方法時，要注意是否會回傳nil，否則它就不能像scope一樣能串接其他方法進行多重查詢參考資料：http://blog.plataformatec.com.br/2013/02/active-record-scopes-vs-class-methods/ https://guides.rubyonrails.org/active_record_querying.html","link":"/2020/02/08/Rails-%E4%B8%AD%E7%9A%84Scope/"},{"title":"Ruby Hash中的 fetch merge slice","text":"fetchfetch可以讓我們想在hash中取值時，能更加客製化輸出結果當我們給的key可能不存在時，例如 123h = {a: 100, b:200}h[:a] #100h[:k] #nil 可以用h.fetch(:key, default output)或是h.fetch(:key){block}讓結果更有彈性。但若沒有給default如下面第二個測試，就會出現key not found 的error用法如下 12345h = {a: 100, b:200}h.fetch(:a) #100h.fetch(:k) #key not found: :kh.fetch(:k, 'see?') #see?h.fetch(:k){|e| &quot;see? #{e}&quot;} #see? k 參考連結 https://apidock.com/ruby/Hash/fetch merge將兩個hash合併，若帶進去方法的hash有重複的key，就去更新對應到的值，並且回傳一個新的hash假設我有兩個hash 1234a = {a: 10, b: 20}b = {a: 30, c: 40, d: 50}a.merge(b) # {a: 30, b: 20, c: 40, d: 50}b.merge(a) # {:a=&gt;10, :c=&gt;40, :d=&gt;50, :b=&gt;20} 也可以用block去處理簡單的邏輯 12a.merge(b) {|key, oldval, newval| newval - oldval}# {:a=&gt;20, :b=&gt;20, :c=&gt;40, :d=&gt;50} 在應用層面，假設今天去打了某個API，得到一坨jason，可以先用symbolize_keys 把所有東西轉成符號為key的hash，再用merge去做對應的邏輯處理，最後儲存到資料庫裡，類似這樣: Table.new(處理好的hash) 參考連結 https://apidock.com/ruby/Hash/merge slice把對應到的key,value 切下來，組裝成新的hash 12{ a: 1, b: 2, c: 3, d: 4 }.slice(:a, :b)# =&gt; {:a=&gt;1, :b=&gt;2} 假設今天打了某之api,得到一坨json，就不這樣寫 12345respons = {data from api}insert_data = {key1: respons[對應的key1], key2: respons[對應的key2]}改成這樣寫insert_data = respons.slice(對應的key1, 對應的key2) 參考連結 https://apidock.com/rails/Hash/slice","link":"/2020/03/04/Ruby-Hash%E4%B8%AD%E7%9A%84-fetch-merge-slice/"},{"title":"Ruby “Include” 跟 “extend” 的差異","text":"1234567891011121314module Run def run_and_jump p 'I\\'m tired' endendclass Man include Runendclass Child extend RunendMan.new.run_and_jump #&quot;I'm tired&quot;Child.new.run_and_jump # NoMethodErrorChild.run_and_jump #&quot;I'm tired&quot; 先做一個Run模組，分別把他include 還有extend到兩個class上透過上面的測試可以發現，include代表Man 類別需要new一個新的物件實體，然後才能使用 include掛上去的方法。 extend則是在Extend掛上去的類別中使用它，可以直接把方法拿過來當成class method。 最後我做了個小實驗，掛上去的方法能被繼承嗎？ 123456class Baby &lt; Childendclass Baby2 &lt; ManendBaby.run_and_jump #&quot;I'm tired&quot;Baby2.new.run_and_jump #&quot;I'm tired&quot; 看來是蠻順利的～","link":"/2020/02/08/Ruby-%E2%80%9CInclude%E2%80%9D-%E8%B7%9F-%E2%80%9Cextend%E2%80%9D-%E7%9A%84%E5%B7%AE%E7%95%B0/"},{"title":"什麼是 Exception Handling？在 Ruby 中怎麼寫例外處理？什麼情況下會用到？","text":"這邊先簡單舉個例子，看看begin , rescue, raise, ensure 怎麼運作 12345678910111213141516171819202122a = 0begin puts a if a &lt; 5 raise # 引發例外，進入 rescue else puts &quot;#{a} is bigger than 4&quot; endrescue a += 1 retryensure p &quot;finished&quot;end#0#1#2#3#4#5#5 is bigger than 4#&quot;finished&quot; 放在 begin 和 end 這兩個關鍵字中的方法或程式區塊（block）都可以使用 rescue 來攔截例外狀況。在測試的過程中，我們可以使用 raise 來引發錯誤，讓它進入到 rescue 中： retry：當你在 rescue 區塊中捕捉到例外時，可以使用 retry 來再次從 begin 開始執行。 raise： 這個方法可以引發一個例外（exception），它會打斷原本程式執行的流動，例如使用 raise。 else： 會寫在 rescue 後， ensure 之前，當程式碼的主體（begin 中的內容）沒有被引發例外的話，else 就會被執行。 ensure： 則可以確保某段程式碼一定會在區塊的最後被執行，不論例外是否有被引發（raise）。 在rails 中碰到問題可以這樣客製化例外處理，比如說找不到資料或是尚未有任何資料，就可以用rescue回傳“請新增資料” 123456789101112begin # do something dodgyrescue ActiveRecord::RecordNotFound # handle not found errorrescue ActiveRecord::ActiveRecordError # handle other ActiveRecord errorsrescue # StandardError # handle most other errorsrescue Exception # handle everything else raiseend 這邊舉個例子 在rails 建立一個model Taskclass Task &lt; ApplicationRecord def self.find_task(id) find(id) rescue ActiveRecord::RecordNotFound p “no this task “ endend假設目前沒有Task 預設Task.find(1) #ActiveRecord::RecordNotFound用例外處理的方法 Task.find_task(1) #”no this task “ 參考資料：https://pjchender.github.io/2018/06/05/ruby-error-handling%EF%BC%88%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86%EF%BC%89/ https://stackoverflow.com/questions/3694153/catch-all-exceptions-in-a-rails-controller","link":"/2020/02/08/%E4%BB%80%E9%BA%BC%E6%98%AF-Exception-Handling%EF%BC%9F%E5%9C%A8-Ruby-%E4%B8%AD%E6%80%8E%E9%BA%BC%E5%AF%AB%E4%BE%8B%E5%A4%96%E8%99%95%E7%90%86%EF%BC%9F%E4%BB%80%E9%BA%BC%E6%83%85%E6%B3%81%E4%B8%8B%E6%9C%83%E7%94%A8%E5%88%B0%EF%BC%9F/"},{"title":"初心者對於Ruby中符號(symbol)的感受","text":"符號、字串、變數在剛接觸到Ruby時實在讓人非常困惑，這邊先簡單比對符號跟字串的特性，再讓變數跟他們互動一下。再Ruby中，變數、字串、符號都是一種物件，符號就跟數字一樣會是不可變的物件，字串則是可變動的物件，如下：我們確認三次”aaa”的object_id(記憶體之海中的位置)，發現每次都有所不同，在新手如我還不了解大多數功能時，看起來就是個很彈性能夠任意調整內容的東西，就算我沒在終端機修改任何字元，Ruby也都會運用不同的記憶體來面對新的指令。 接下來我們看看數字跟符號。 符號跟數字一樣都是用相同的記憶體欸，感覺就像老早就刻好放在那裡剛好被object_id檢查到顯示出來（數字確實是有固定規律2n+1)。從上面的小檢測可以看出“符號”vs“字串”就是“不可變動的值”vs“可變動的值”說到“值”就想到最初使用irb時都會打 這裡a就是指向“1”這個值，a本身是變數沒有被賦予意義，要有一個值才會存在。最後提到符號的應用，因為符號有不可變的特性，所以適合拿來作為固定標示，如雜湊(Hash)的 Key。舉個例子：profile = { name: ‘Gary’, height: ‘not_tall’ } 這個Hash如果沒有穿語法糖衣長這樣profile = {:name =&gt; ‘Gary’, :height =&gt; ‘not_tall’ }看起來就是用定型的key（符號）去得到value吧～～","link":"/2019/11/20/%E5%88%9D%E5%BF%83%E8%80%85%E5%B0%8D%E6%96%BCRuby%E4%B8%AD%E7%AC%A6%E8%99%9F-symbol-%E7%9A%84%E6%84%9F%E5%8F%97/"}],"tags":[],"categories":[]}